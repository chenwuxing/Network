# TCP&IP

## 概述

TCP/IP通常被认为是一个四层协议系统，每一层负责不同的功能

1. 链路层，通常包括操作系统中的设备驱动程序和计算机中对应的网络接口卡，协作处理与电缆的物理接口细节
2. 网络层，处理分组在网络中的活动，在TCP/IP协议族中，网络层协议包括IP协议、ICMP协议、IGMP协议
3. 运输层，为两台主机上的应用程序提供端到端的通信。包括TCP、UDP
4. 应用层，负责特定的应用程序细节

OSI模型

1. 应用层，提供为应用软件而设的接口，以设置与另一应用软件之间的通信
2. 表达层，把数据转换为能与接收者的系统格式兼容并适合传输的格式
3. 会话层，负责在数据传输中设置和维护电脑网络中两台电脑之间的通信连接
4. 传输层，把传输表头加之数据以形成数据包，传输表头包含了所使用的协议等发送信息
5. 网络层，决定数据的路径选择和转寄，将网络表头加至数据包，以形成报文
6. 数据链接层，负责网络寻址、错误侦测和改错，当表头和表尾被加至数据包时，会形成信息框，数据链表头包含了物理地址和错误侦测及改错的方法
7. 物理层，在局域网上传送数据帧，负责电脑通信设备和网络媒体之间的互通，包括电压、网卡、主机接口卡等

### 互联网地址

1. A 0.0.0.0~127.255.255.255
2. B 128.0.0.0~191.255.255.255
3. C 192.0.0.0~223.255.255.255
4. D 224.0.0.0~239.255.255.255

<br/>

## 链路层

### 链路层的主要目的

1. 为IP模块发送和接收IP数据报
2. 为ARP模块发送ARP请求和接收ARP应答
3. 为RARP发送RARP请求和接收RARP应答

### 以太网帧结构

| 6        | 6      | 2    | MTU:46-1500字节 | 4       |
| -------- | ------ | ---- | --------------- | ------- |
| 目的地址 | 源地址 | 类型 | 数据            | CRC校验 |



### 串行接口链路层协议

1. SLIP

   缺点：

   ​			1）每一端必须知道对方的IP地址，没有办法把本端的IP地址通知给另一端

   ​			2）数据帧中没有类型字段，如果一条串行线路用于SLIP，那么它不能同时使用其他协议

2. PPP(点对点协议)

   | 标志 | 地址 | 控制 | 协议    | 信息 | CRC     | 标志 |
   | ---- | ---- | ---- | ------- | ---- | ------- | ---- |
   | 7E   | FF   | 03   | 2个字节 |      | 2个字节 | 7E   |

   相较与SLIP的优点：

   - 支持在单根串行线路上运行多种协议，不只是IP协议
   - 每一帧都有循环冗余检验
   - 通信双方可以进行IP地址的动态协商

   PPP协议的三个组成部分

   - 一个将IP数据报封装到串行链路的方法
   - 一个用来建立、配置和测试数据链路连接的链路控制协议LCP(Link Control Protocol)
   - 一个网络控制协议NCP(Network Control Protocol)，其中的每一个协议支持不同的网络层协议

   

3. 环回接口

### MTU(最大传输单元)

穿输中数据的长度限制

<br/>

## IP

### IP的特点

1. 不可靠，不能保证IP数据报能成功到达目的地
2. 无连接，IP不维护任何关于后续数据报的状态信息，每个数据报的处理是相互独立的

### IP首部

![](/home/wuxing/Pictures/Work/ip数据报格式.png)

1. 版本，占4位，指IP协议的版本
2. 首部长度，占4位
3. 区分服务，占8位
4. 总长度，占16位，首部和数据之和的长度，单位为字节
5. 标示，占16位，IP软件在存储器中维持一个计数器，每产生一个数据报，计算器就加1，并将此值赋给标示字段，当数据报由于长度超过网络的MTU而必须分片时，这个标示字段的值就被复制到所有的数据报片的标示字段中，相同的标示字段的值使分片后的各数据报片最后都能正确重装成为原来的数据包
6. 标志，占三位，但目前只有两位有意义
   - 标志字段中的最低位记为MF(more fragment)，MF等于1表示后面还有分片的数据包，等于0表示这是若干数据报片中的最后一片
   - 中间一位记为DF(Don't Fragment)，意思是不能分片，只有当DF等于0时才允许分片
7. 片偏移，占13位，指出较长的分组在分片后，某片在原分组中的相对位置，片偏移以8个字节为偏移单位
8. 生存时间，占8位
9. 协议，占8位，指出次数据报携带的数据是使用何种协议
10. 首部检验和，只检验数据报的首部，不包括数据部分
11. 源地址，32位
12. 目的地址，32位

### IP校验和计算

1. 把校验和字段以全零填充
2. 对每16bit字进行二进制反码求和
3. 得到的结果即为首部校验和

### IP路由选择的功能

1. 搜索路由表，寻找能与目的IP地址完全匹配的表目，如果找到，则把报文发送给该表目指定的下一站路由器或直接连接的网络接口
2. 搜索路由表，寻找能与目的网络号相匹配的表目，如果找到，则把报文发送给该表目指定的下一站路由器或直接连接的网络接口
3. 搜索路由表，寻找默认的表目，如果找到，就把该报文发送给该表目指定的下一站路由器

### 子网寻址

不是把IP地址看成单纯的一个网络号和一个主机号组成，而是把主机号再分成一个子网号和一个主机号

#### 为什么这么做

因为A类和B类地址为主机分配了太多的空间，实际上一个网络中并不安排这么多的主机

#### 什么是子网掩码

用来告诉主机有多少比特用于子网号，多少比特用于主机号，形式上是一个32bit的值，其中值为1的比特留给网络号和子网号，为0的比特留给主机号。

#### IP地址结合子网掩码实现什么功能

确定IP数据报的目的是：

1. 本子网上的主机
2. 本网络中其他子网中的主机
3. 其他网络上的主机

### ICMP(Internet控制报文协议)

### 为什么需要ICMP?

在通信过程中，经常有数据报由于一些原因到不了目的端，在错误发生的现场，ICMP被当做信鸽一样传递给发送方以告知发生了何种事件

#### 具有什么功能？

1. 差错通知

   给发送者的错误通知，发生时机是当IP数据报被对方的计算机处理过程中，发生了什么错误时被使用

2. 信息查询

#### 如何传输的？

ICMP是在IP数据报内部被传输的

#### ICMP报文格式

| 8位类型  | 8位代码 | 16位检验和 |
| -------- | ------- | ---------- |
| 不定内容 |         |            |

#### IP选路

IP路由操作对于运行TCP/IP的系统是最基本的，不管是主机还是路由器。路由表项的内容包括目的IP地址、下一站路由器的IP地址(间接路由)或者本地接口的IP地址(直接路由)以及指向本地接口的指针

##### ICMP主机与网络不可达差错

当路由器收到一份IP数据报但又不能转发时，就要发送一份ICMP“主机不可达”差错报文

##### ICMP重定向差错

当IP数据报应该被发送到另一个路由器时，收到数据报的路由器就要发送ICMP重定向差错报文给IP数据报的发送端

重定向一般用来让具有很少路由信息的主机逐渐建立更完善的路由表，主机启动时可以只有一个默认表项，一旦默认路由发生差错，默认路由器将通知它进行重定向，并允许主机对路由表做相应的改动

##### ICMP路由器发现报文

一般认为，主机在引导以后要广播或多播传送一份路由器请求报文，一台或更多台路由器相应一份路由器通告报文，路由器定期地广播或多播传送它们的路由器通知报文，允许每个正在监听的主机相应的更新它们的路由表



#### 动态选路协议RIP(Routing Information Protocol)

**三个问题，和哪些路由器交换信息？交换什么信息？什么时候交换? **

##### 两种基本的选路协议

1. IGP，内部网关协议
2. EGP，外部网关协议



用于路由器间的通信,相邻路由器之间进行通信以告知对方每个路由器当前所连接的网络

##### 谁执行这个协议？做了什么？

路由器上的一个称为路由守护程序的进程，它根据从相邻路由器接收到的信息，更新内核中的路由表

##### 路由守护进程如何做的？

它将选路策略加入到系统中，选择路由并加入到内核的路由表中，如果发现前往同一信宿存在多条路由，那么它将选择最佳路由并加入到内核路由表中，当发现断开的链路时，它可以删除受影响的路由



##### RIP协议报文格式

RIP报文包含在UDP数据报中

##### 采用RIP协议的路由守护程序是如何运行的？

1. 初始化，判断启动了哪些接口，并在每个接口上发送一个请求报文
2. 接收到请求，如果收到来自others的特殊请求，那么路由器就将完整的路由表发送给请求者
3. 接收到请求，使相应生效，可能会更新路由表或增加新表项，对已有的表项进行修改或是将已有表项删除
4. 定期路由选路更新，每过30秒，所有或部分路由器会将其完整路由表发送给相邻路由器
5. 触发更新，每当一条路由的度量发生变化时，就对它进行更新，不需要发送完整路由表，而只需发送那些变化的表项

RIP特点

- 仅和相邻路由器交换信息
- 路由器交换的信息是当前本路由器所知道的全部信息，即自己现在的路由表，即“我到本自治系统中所有网络的最短距离，以及到每个网络应经过的下一跳路由器
- 按固定的时间间隔交换路由信息

##### RIP的问题

1. 没有子网地址的概念
2. 可能发生路由环路
3. 采用跳数限制了RIP网络的大小

##### OSPF(开放最短路径优先)

除RIP外的另一个内部网关协议，克服了RIP的所有限制

##### OSPF与RIP的差异

1. RIP采用距离向量，OSPF是一个链路状态协议
2. 链路状态协议总是比距离向量协议手链更快
3. OSPF直接使用IP

OSPF特点：

- 向本自治系统中所有路由器发送信息
- 发送的信息是与本路由器相邻的所有路由器的链路状态，链路状态就是说明本路由器和哪些路由器相邻，以及该链路的度量
- 只有当链路状态发生时，路由器才向所有路由器用洪泛法发送此信息

##### OSPF相较于RIP的优点？

1. 可以对每个IP服务类型计算各自的路由集
2. 给每个接口指派一个无维数的费用
3. 当对同一个目的地址存在多个相同费用的路由时，OSPF在这些路由上平均分配流量
4. OSPF支持子网
5. 路由器之间的点对点链路不需要每端都有一个IP地址
6. OSPF采用多播

##### OSPF如何工作？

路由器并不与其邻站交换距离信息，采用的是每个路由器主动地测试与其邻站相连链路的状态，将这些信息发送给它的其他邻站，而邻站将这些信息在自治系统中广播出去。每个路由器接收这些链路状态信息，并建立完整的路由表

#### BGP(边界网关协议)

使用TCP作为其传输层协议，两个运行BGP的系统之间建立一条TCP连接，然后交换整个BGP路由表，BGP是一个距离向量协议

##### 自治系统分类

1. 残桩自治系统，与其他自治系统只有单个连接

2. 多接口自治系统，与其他自治系统有多个连接，但拒绝传送通过流量

3. 转送自治系统，与其他自治系统有多个连接，在一些策略准则下，可以传送本地流量和通过流量

   

   

#### CIDR(无类型域间路由)

B类地址缺乏，现在多个网络站点只能采用多个C类网络号，而不采用单个B类网络号，但是每个C类网络都需要一个路由表项，为了防止路由表膨胀，提出了CIDR















OSPF相较于RIP的优点？





## ARP&RARP

### ARP的作用范围？功能？

只对TCP/IP协议簇有意义的IP地址，ARP为两种不同的地址形式提供映射

1. 32bit的IP地址
2. 数据链路层使用的任何类型的地址

ARP就是将逻辑Internet地址翻译成物理硬件地址

### 具有本地磁盘的系统引导可以从磁盘上配置文件读取IP地址，那无盘机如何获取IP？

从接口卡上读取唯一的硬件地址，然后发送一份RARP请求，请求某个主机相应该无盘系统的IP地址



## UDP(用户数据协议报)

UDP是一个简单的面向数据报的传输层协议：进程的每个输出操作都正好产生一个UDP数据报，并组装成一份待发送的IP数据报

### UDP首部

![](/home/wuxing/Pictures/Work/udp_首部.png)

### UDP检验和

UDP检验和覆盖UDP首部和UDP数据，IP首部的检验和只覆盖IP的首部，并不覆盖IP数据报中的任何数据

其特点：

- UDP数据报的长度可以为奇数字节，为解决检验和算法是把若干个16bit字相加，必要时在最后填充字节0，只是为了检验和的计算
- UDP数据报和TCP段都包含一个12字节长的伪首部，是为了计算检验和而设置的，伪首部包含IP首部一些字段，其目的是让UDP两次检查数据是否已经正确到达目的地

### IP分片

物理网络层一般要限制每次发送数据帧的最大长度，任何时候IP层接收到一份要发送的IP数据报时，它要判断向本地哪个接口发送数据，并查询该接口获得其MTU，IP把MTU与数据报长度进行比较，如果需要则进行分片，分片可以发生在原始发送端主机上，也可以发生在中间路由器上

#### MTU

MTU即Maximum Transmission Unit，最大传输单元，它是指一种通信协议的某一层面上所能通过的最大数据包大小

##### 路径MTU

一条因特网传输路径中，从源地址到目的地址所经过的“路径”上的所有IP跳的最大传输单元的最小值

##### 路径MTU的发现方法

目的是为了避免IP分片

设置DF标志位，标志不分片，在逐渐增大发送的数据报的大小-路径上任何需要将分组进行分片的设备都会将这种数据报丢弃并返回“数据报过大”的ICMP相应到源地址，这样源地址就可以学习到无须分片就能通过这条路径的最大的传输单元

##### TraceRoute

用来侦测主机到目的主机之间所经路由情况的重要工具

#### 最大UDP数据报长度

理论值IP数据报的最大长度是65535字节，去除20字节的IP首部和8个字节的UDP首部，UDP数据报中用户数据的最大长度为65507字节，但是实际实现受以下限制

1. 应用程序可能会受到其程序接口的限制
2. TCP/IP的内核实现

#### ICMP源站抑制差错

当一个系统接收数据报的速度比其处理速度快时，可能产生这个差错



## 广播和多播

广播和多播仅应用于UDP，它们对需将报文同时传往多个接收者的应用来说十分重要

### 协议栈各层对收到帧的过滤过程

1. 接口卡
2. 设备驱动程序
3. IP
4. UDP

### 多播的作用

多播的出现减少了对应用不感兴趣主机的处理负荷，使用多播，主机可以加入一个或多个多播组。这样网卡将获悉该主机属于哪个多播组，然后仅接收主机所在多播组的那些多播帧

#### IP多播提供的服务

1. 向多个目的地址发送数据
2. 客户对服务器的请求

#### 多播组地址

D类IP地址，1110+28位多播组ID

能够接收发往一个特定多播组地址数据的主机集合称为主机组，一个主机组可以跨越多个网络，主机组中成员可随时加入或离开主机组

### 四种IP广播地址

1. 受限的广播，255.255.255.255
2. 指向网络的广播，主机号全为1的地址
3. 指向子网的广播，主机号为全1且有特定子网号的地址
4. 指向所有子网的广播，子网号及主机号全为1

## IGMP(Internet组管理协议)

用于支持主机和路由器进行多播的协议，它让一个物理网络上的所有系统知道主机所在的多播组

### 报文格式

![](/home/wuxing/Pictures/Work/igmp.png)

- 类型为1说明是由多播路由器发出的查询报文，为2说明是主机发出的报告报文
- 组地址为D类IP地址，查询报文中设置为0，报告报文中组地址为要参加的组地址

## DNS(域名系统)

一种用于TCP/IP应用程序的分布式数据库，它提供主机名字和IP地址之间的转换及有关电子邮件的选路信息

### 如何使用？

对DNS的访问是通过一个地址解析器来完成的，在Unix主机中，该解析器主要是通过两个库函数gethostbyname和gethostbyaddr来访问的

### 报文格式

![](/home/wuxing/Pictures/Work/dns.png)



## TFTP(简单文件传送协议)





## BOOTP(引导程序协议)



## TCP(传输控制协议)

### TCP如何控制可靠性

- 应用数据被分割成TCP认为最适合发送的数据块，TCP传递给IP的信息单位称为报文段或段
- TCP发出一个段后，启动一个定时器，等待目的端确认收到这个报文段，如果不能及时收到一个确认，将重发这个报文段
- 当TCP收到发自TCP连接另一端的数据，它将发送一个确认，这个确认不是立即发送，通常将推迟几分之一秒
- TCP将保持它首部和数据的检验和，这是一个端到端的检查和，目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP将丢弃这个报文段和不确认收到此报文段
- TCP报文段作为IP数据报来传输，而IP数据报的到达可能会失序，因此TCP报文段的到达也可能会失序，如果必要，TCP将对收到的数据进行重新排序，将收到的以正确的顺序交给应用层
- IP数据报会发生重复，TCP的接收端必须丢弃重复的数据
- TCP还能提供流量控制，TCP连接的每一方都有固定大的缓冲空间，TCP的接收端只允许另一端发送接收端缓冲区所能接纳的数据，这将防止较快主机致使较慢主机的缓冲区溢出

### TCP首部

![](/home/wuxing/Pictures/Work/tcp.png)

- 端口号：用于寻找发端和收端应用进程

- Sequence Number：用来标示从TCP发端向TCP收端发送的字节流，它表示在这个报文段中的第一个数据字节，解决网络包乱序问题

- Acknowledge Number:用于确认收到，用来解决不丢包的问题

- Window:著名的滑动窗口，用于解决流控的，指发送本报文段的一方的接收窗口，窗口值作为接收方让发送方设置其发送窗口的依据

- TCP Flag:包的类型

  - SYN:在建立连接时用来同步序号，表示一个连接请求或连接接收报文

  - ACK：确认序号有效

  - URG：紧急指针

  - PSH：接收方应该尽快将这个报文段交给应用层

  - RST：连接中出现严重差错，必须释放连接，然后再重新建立连接

  - FIN：发端完成发送任务



## TCP连接的建立与终止

### 建立连接

1. 请求端发送一个SYN段指明客户打算连接的服务器的端口，以及初始序号(ISN)，这个SYN段为报文段1
2. 服务器发回包含服务器的初始序号的SYN报文段作为应答，同时，将确认序号设置为客户的ISN加1以对客户的SYN报文段进行确认，一个SYN将占用一个序号
3. 客户必须将确认序号设置为服务器的ISN加1以对服务器的SYN报文段进行确认

这三个报文段完成连接的建立，称为三次握手

对于建链接的3次握手，主要是初始化Sequence Number的初始值，通信的双方要通知对方的初始化的Sequence Number，这个号作为以后的数据通信的序号，以保证应用层接收的数据不会因为网络上的传输问题而乱序

### 断开连接

1. 客户端发送一个FIN，用来关闭客户端到服务器方向的连接
2. 服务器收到来自客户端的FIN段后，发送一个ACK，确认序号为收到的序号加1
3. 服务器发送一个FIN给客户端
4. 客户端发回ACK报文确认，将确认序号设置为收到的序号加1

其实是两次，因为TCP是全双工的，所以发送发和接收方都需要FIN和ACK，只不过有一方是被动的，所以看上去就成了四次，如果两边同时断开连接，那就会进入到Closing状态，然后到达TIME_WAIT状态器上的某一块网卡的网络包，当你的机器上有多块网卡的时候，你需要器上的某一块网卡的网络包，当你的机器上有多块网卡的时候，你需要器上的某一块网卡的网络包，当你的机器上有多块网卡的时候，你需要器上的某一块网卡的网络包，当你的机器上有多块网卡的时候，你需要

### 最大报文长度

MSS表示TCP传往另一端的最大块数据的长度，MSS选项只能出现在SYN报文段中

### TCP的半关闭

TCP提供了连接的一端在结束它的发送后还能接收来自另一端数据的能力

为了使用这个特性，编程接口必须为应用程序提供一种方式来说明“我已经完成了数据传送，因此发送一个文件结束(FIN)给另一端，但我还想接收另一端发来的数据，直到它给我发来文件结束(FIN)”

### TCP状态变迁图

![](/home/wuxing/Pictures/Work/tcp状态变迁图.png)

### TCP状态

![](/home/wuxing/Pictures/Work/tcp状态.png)

#### MSL(报文段最大生存时间)

任何报文段被丢弃前在网络内的最长时间

#### 复位报文段

TCP首部中的RST比特是用于复位的，一般来说，无论何时一个报文段发往基准的连接出现错误，TCP都会发出一个复位报文段

1. 到不存在的端口的连接请求
2. 异常终止一个连接
3. 检测半关闭连接



## TCP的交互数据流

### 交互数据流分类

1. TCP交互数据流，一般情况下总是以小于MSS的分组发送，做的是小流量的数据交互，常见的应用比如SSH，Telnet
2. TCP成块数据流，TCP尽最大能力的运载数据，数据基本都是按照MSS发送，常见的应用有FTP

### Delay ACK

延时发送ACK，在收到数据包的时候，会检查是否需要发送ACK，如果需要的话，进行快速ACK或延时ACK，在无法使用快速确认的情况下，就会用到延时ACK

TCP在何时发送ACK的时候有如下规定：

1. 当有相应数据发送的时候，ACK会随着数据一块发送
2. 如果没有相应数据，ACK就会有一个延迟，以等待是否有数据一块发送，延迟一般在40ms至500ms之间，一般情况下在40ms左右，如果在40ms内有数据发送，那么ACK会随着数据一块发送，对于这个延迟需要注意的是，这个延迟并不是收到数据至发送ACK的时间延迟，而是内核启动一个定时器，每隔200ms就会检查一次，比如定时器在0ms启动，200ms到期，180ms的时候data来到，如果200ms的时候没有相应数据，ACK依然会被发送，这个时候延迟了20ms
3. 如果在等待发送ACK期间，第二个数据又到了，这时候要立即发送ACK

延迟的优点：减少了数据段的个数，提高了发送效率

延迟的缺点：过多的delay会拉长RTT



## 滑动窗口协议

### 解决的是什么问题？

IP层协议属于不可靠的协议，IP层并不关系数据是否发送到了对端，TCP通过确认机制来保证数据传输的可靠性，在比价早的时候使用的是send-wait-send模式(停止等待协议)，发送方在发送数据后启动定时器，但是如果数据或者ACK丢失，那么定时器到期之后，收不到ACK就认为发送出现情况，要进行重传，这样降低了通信的效率

TCP需要解决可靠传输以及包乱序问题，所以TCP需要知道网络实际的数据处理带宽或是数据处理速度，这样才不会引起网络拥塞，导致丢包，滑动窗口便是控流技术的一种，滑动窗口属于流水线型作业



![](/home/wuxing/Pictures/Work/tcp_滑动窗口.png)

为了优化这种传递方式，可以让发送的每一个包都有一个id，接收端必须对每一个段进行确认，这样设备A一次可以发送几个片段，而不必等候ACK，同时接收端也要告知发送端它能接收多少，这样对发送端发送数据速度有控制作用，当然还需要保证顺序性，对于乱序的情况，可以允许等待一定情况下的乱序，比如说先缓存提前到的段，然后去等待需要的数据，如果一段时间没来就丢掉，保证顺序性

### 滑动窗口

TCP发送端数据段的分类

1. sent and acknowledged:这些数据表示发送成功并已经被确认的数据，这些数据并不在窗口内
2. sent but not yet acknowledge:已经发送但没有被确认，没有收到接收端的ACK，认为没有完成发送，属于窗口内的数据
3. not sent,recipient ready to receive,尽快发送的数据，这部分数据已经被加载到缓存中，也就是窗口中，等待发送，接收方告知还是能够接收这些包，所以发送方需要尽快的发送这些包
4. not sent，recipient not ready to receive，这些数据属于未发送，同时接收端也不允许发送的，因为超出了接收端接收的范围

TCP接收端数据段分类

1. 已经发送确认并交付给主机
2. received not ACK:已经接收 ，但是还没有回复ACK，这些包可能属于延时ACK的范畴了
3. not received:有空位，还没有被接收的数据
4. 不允许接收

发送窗口和可用窗口：

对于发送方来讲，窗口内包括两部分

1. 发送窗口：已经发送，还没接收到ACK
2. 可用窗口，接收端允许但是还没有发送

PUSH标志

通知TCP模块什么时候将数据发送出去，以及read函数什么时候将数据从接收缓冲区读取

#### 缓存与窗口的关系

![](/home/wuxing/Pictures/Work/缓存与窗口.png)

发送缓存用来暂时存放：

- 发送应用程序传送给发送方TCP准备发送的数据
- TCP已发出但尚未收到确认的数据

接收缓存用来暂时存放：

- 按序到达的、但尚未被接收应用程序读取的数据
- 未按序到达的数据

## TCP超时与重传

### TCP管理的四种定时器

1. 重传定时器使用于当希望收到另一端的确认
2. 坚持定时器使窗口大小信息保持不断流动，即使另一端关闭了其接收窗口
3. 保活定时器可以检测到一个空闲连接的另一端何时崩溃或重启
4. 2MSL定时器测量一个连接处于TIME_WAIT状态的时间

### 何时触发超时

1. 发送方丢包
2. 接收方确认丢失或延迟

### RTT&RTO

确定超时重传的重要一步是测量RTT的值，根据RTT的值依据算法得到RTO的值，TCP在收到接收方回应时更新计算当时的RTT，当超时重传发生时，在重传数据的确认最后到达之前不能重新计算RTT

如果设长了，重发就慢，丢包半天才重发

如果设短了，会导致可能没有丢包就重发，会增加网络拥塞，导致更多的超时

#### 重传时间

RTT(Round Trip Time)
$$
新的SRTT=(1-α)×(旧的SRTT)+α×(新的RTT样本)
$$
推荐α等于0.125，这样得出的SRTT比RTT更加平滑

RTO(Retransmission TimeOut)

RTO应略大于上面得出的加权RTTS略大，RFC6298建议计算方式：
$$
RTO=SRTT+4×DRTT
$$
DRTT是RTT的偏差的加权平均值，当第一次测量时，DRTT值取为测量到的RTT样本值的一半，在以后的测量中，使用如下公式计算加权平均的DRTT：
$$
新的DRTT=(1-β)×(旧的DRTT)+β×|SRTT-新的RTT样本|
$$
β推荐0.25

#### 触发重传后RTT大小的问题？

发出一个报文段，计时器用完，没有收到确认，触发重传，经过一段时间收到确认报文段，但是**如何判定此确认报文段是对先发送的报文段的确认，还是对后来重传的报文段的确认？**

这会影响确定SRTT的大小

- 若收到的是对重传报文段的确认，但却被源主机当成是对原来的报文段的确认，这样计算出的SRTT偏大
- 若收到的是对原来的报文段的确认，但被当成是对重传报文段的确认，则计算出的SRTT偏小

#### 解决问题的经典算法

#### Karn/Patridge算法

在计算加权平均SRTT时，只要报文段重传了，就不采用其往返时间样本，这样得出的SRTT和RTO就比较准确





### 超时重传机制

接收端给发送端的ACK确认只会确认最后一个连续的包，SeqNum和Ack是以字节数为单位，所以ack的时候，不能跳着确认，只能确认最大的连续收到的包，例如客户端发送1,2,3,4,5共五个数据，接收端收到了1,2，于是回ack 3,然后收到了4，此时TCP可以不回复ack，等待3这个数据段的到来

一种是不回ack，一直等待数据段3，当发送方发现收不到3的ack而超时后，会重传3，一旦接收方收到3后，会ack回4--意味着3和4都收到了

但是这会导致4即便已经收到了，发送方也不知道发生了什么，可能会导致4的重传

对此有两种选择：

- 仅重传timeout的包，也就是第三个数据段
- 另一种是重传timeout后所有的数据

#### 快速重传机制

不以时间驱动，而以数据驱动重传，如果包没有连续到达，就ack最后那个可能被丢了的包，如果发送方连续收到3次相同的ack，就重传，快速重传的好处就是不用等待timeout触发了再重传

但是快速重传机制依然没有解决一个问题，触发重传之后到底是只重传触发重传的那个数据段还是包括那个数据段之后的数据也一并重传，因为发送端并不清楚连续的3个ack是谁传回来的(包到达的顺序不一定的)，发送端很有可能重传从3开始的数据段

采用快速重传算法可以让发送方尽早知道发生了个别报文段的丢失，要求接收方不要等待自己发送数据时才进行捎带确认，而是立即发送确认，即使收到失序的报文段也要立即发出对已收到的报文段的重复确认

#### SACK(Selective Acknowledgment)

需要在TCP头里加入一个SACK的东西，ACK还是快速重传的ACK，SACK则是汇报收到的数据碎板，这样发送端可以根据回传的SACK来知道哪些数据到了，哪些没到

![](/home/wuxing/Pictures/Work/sack.jpg)



但是如果一个攻击者给数据发送方发一堆SACK的选项，这会导致发送方开始要重传甚至遍历已经发出的数据，这会消耗很多发送端的资源

Duplicate SACK-重复收到数据的问题

主要使用了SACK来告诉发送方有哪些数据被重复接收

D-SACK使用了SACK的第一个段来做标志

- 如果SACK的第一个段的范围被ACK所覆盖，那么就是D-SACK
- 如果SACK的第一个段的范围被SACK的第二个段覆盖，那么就是D-SACK

引入D-SACK的好处：

1. 可以让发送方知道，是发出去的包丢了，还是回来的ACK包丢了
2. 是不是自己的timeout太小了
3. 网络上出现了先发的包后到的情况
4. 网络上是不是把我的数据包复制了



## TCP拥塞处理

拥塞控制就是防止过多的数据注入到网络中，这样可以使网络中的路由器或链路不致过载



TCP通过一个timer采样了RTT并计算RTO，但是如果网络上的延时突然增加，那么TCP对这个事做出的应对只有重传数据，但是重传会导致网络的负担加重，于是会导致更大的延迟以及更多的丢包，进入恶性循环，TCP协议会拖垮整个网络

所以TCP不能忽略网络上发生的事情，而无脑地重发数据，对网络造成更大的伤害，对此TCP的设计理念是：TCP不是一个自私的协议，当网络拥塞发生的时候，要做自我牺牲

拥塞控制主要是四个算法：

以下拥塞控制也叫基于窗口的拥塞控制，为此，发送方维持一个叫做拥塞窗口cwnd，拥塞窗口的大小取决于网络的拥塞程度，并且动态地变化，发送方让自己的发送窗口等于拥塞窗口

- 慢启动
- 拥塞避免
- 快重传
- 快速恢复

![](/home/wuxing/Pictures/Work/拥塞控制流程图.png)

![](/home/wuxing/Pictures/Work/拥塞控制.png)





